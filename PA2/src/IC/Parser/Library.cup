package IC.Parser;

import IC.*;
import IC.AST.*;
import java.util.List;
import java.util.ArrayList;
import java_cup.runtime.Symbol;


parser code {:

	// override method call in case of a (unrecovered) syntax error
	public void unrecovered_syntax_error(Symbol current_token) throws SyntaxError{
		throw new SyntaxError(current_token.left, (String)current_token.value);
	}
	
	// override method call in case of a syntax error, to avoid duplicate error messages
	public void syntax_error(Symbol current_token){}
	
:};

non terminal ICClass LibIC;
non terminal List<Method> LibMethods;
non terminal LibraryMethod LibMethod;
non terminal Type Type;
non terminal Type ReturnType;
non terminal List<Formal> Formals;

terminal LP,RP,LB,RB,LCBR,RCBR;
terminal ASSIGN,DIVIDE,MOD,MULTIPLY,PLUS,MINUS,UMINUS;
terminal EQUAL,NEQUAL,GT,GTE,LT,LTE;
terminal LAND,LNEG,LOR;
terminal DOT,COMMA,SEMI;
terminal Integer INTEGER;
terminal String ID;
terminal String CLASS_ID;
terminal String QUOTE;
terminal VOID,BOOLEAN,INT,STRING,STATIC;
terminal IF,ELSE,WHILE,CONTINUE,BREAK,RETURN;
terminal CLASS;
terminal EXTENDS,THIS,NEW;
terminal FALSE,TRUE,NULL;
terminal LENGTH;
// Precedences:
precedence left LP, RP, LB, RB;


//LibIC
LibIC ::= CLASS CLASS_ID:id LCBR LibMethods:lm RCBR
	{:
		if (id.compareTo("Library") != 0)
			throw new SemanticError(idleft, "Library class should be called \"Library\" ");
		RESULT = new ICClass(idleft,id,new ArrayList<Field>(),lm);
	:};
	
	
//LibMethods
LibMethods ::= LibMethod:lm
	{:
		List<Method> list = new ArrayList<Method>();
		list.add(lm);
		RESULT = list;
	:}
	|LibMethods:lms LibMethod:lm
	{:
		lms.add(lm);
		RESULT = lms;
	:} ;

//LibMethod
LibMethod::= STATIC ReturnType:type ID:id LP RP SEMI
	{:
		RESULT = new LibraryMethod(type,id,new ArrayList<Formal>());
	:}
	|STATIC ReturnType:type ID:id LP Formals:formals RP SEMI
	{:
		RESULT = new LibraryMethod(type,id,formals);
	:};

//ReturnType
ReturnType ::= VOID:v
	{:
		RESULT = new PrimitiveType(vleft, DataTypes.VOID);
	:}
	| Type:type
	{:
		RESULT = type;
	:};



// formals
Formals ::= Type:type ID:id
	{:
		List<Formal> list = new ArrayList<Formal>();
		list.add(new Formal(type,id));
		RESULT = list;
	:}
	| Formals:f COMMA Type:type ID:id
	{:
		f.add(new Formal(type, id));
		RESULT = f;
	:};

//Type
Type ::= INT:i
	{:
		RESULT = new PrimitiveType(ileft, DataTypes.INT);
	:}
	| BOOLEAN:b
	{:
		RESULT = new PrimitiveType(bleft, DataTypes.BOOLEAN);
	:}
	| STRING:s
	{:
		RESULT = new PrimitiveType(sleft, DataTypes.STRING);
	:}
	| Type:type LB RB
	{:
		type.incrementDimension();
		RESULT = type;
	:};

	